# Code Review: Section 07 - React Frontend Scaffold

The implementation is largely faithful to the plan but has several issues ranging from an architectural deviation to test quality gaps and a subtle test fragility problem.

## HIGH SEVERITY

### 1. TauRPC bindings not used -- direct `invoke` used instead (App.tsx, line 2)
The plan at section 7.6 explicitly states: 'Imports the TauRPC-generated bindings from ./bindings (generated by the Tauri backend build step into src/bindings.ts).' The implementation instead uses raw `invoke` from `@tauri-apps/api/core`. This is a significant architectural deviation. TauRPC bindings provide type-safe IPC calls; raw `invoke` is stringly-typed and loses all the type safety that TauRPC was configured to provide in section-05. If the health_check command signature changes in the Rust backend, the frontend will silently break at runtime rather than failing at compile time. The mock in `setup.ts` (line 4) also mocks `@tauri-apps/api/core` instead of the TauRPC client, which means tests would not catch binding mismatches either.

### 2. `invoke` swallows all errors silently (App.tsx, lines 13-16)
The `catch(() => setStatus('error'))` discards the error entirely. There is no logging, no console.error, no error boundary integration. In a desktop application, a failed IPC health check could indicate that the Tauri backend process crashed or that the command name is wrong. Silently eating this error makes debugging in production extremely difficult. At minimum, the error should be logged to console or stored in state for diagnostic display.

## MEDIUM SEVERITY

### 3. Redundant dark mode application -- belt AND suspenders without clarity (App.tsx, lines 9-11 vs index.html, line 2)
The `index.html` already sets `class="dark"` on the `<html>` element (line 2). Then `App.tsx` has a `useEffect` on line 9-11 that does `document.documentElement.classList.add('dark')` again. This is redundant. More problematically, it creates a coupling that makes the dark mode source of truth ambiguous. If someone removes the class from `index.html` thinking the component handles it, or vice versa, the behavior will differ between SSR/initial paint and post-hydration. The plan says to apply it in `index.html` OR programmatically -- not both. Pick one and document the decision.

### 4. Tests do not verify error state at all (App.test.tsx)
The plan section on tests says to verify the status indicator. However, all four tests only test the happy path (the mock in setup.ts always resolves successfully). There is no test for the error state: what happens when `invoke` rejects? The component has three states ('loading', 'connected', 'error') but only 'connected' is ever tested. At minimum, one test should override the mock to reject and assert that 'IPC Error' text and the red dot appear.

### 5. Tests are brittle due to global mock setup (setup.ts, lines 4-6)
The `vi.mock` for `@tauri-apps/api/core` is in the global setup file, which means every single test file in the project will have this mock applied, even tests that have nothing to do with IPC. This makes it impossible to test actual IPC integration later without restructuring. The mock should be scoped to the test files that need it, or at minimum the setup file should be specific to the App tests, not the global test setup.

### 6. `afterEach` cleanup is outside the `describe` block (App.test.tsx, lines 4-7)
The `afterEach` that removes the 'dark' class is placed at the module level, outside the `describe('App', ...)` block. While Vitest will still run it, this is poor test hygiene. If another `describe` block is added to this file, the cleanup will affect it unexpectedly. It should be inside the describe block.

## LOW SEVERITY

### 7. No `bindings.ts` placeholder or stub file exists
The plan states TauRPC generates `src/bindings.ts`. Since the implementation chose raw `invoke` instead, there is no `bindings.ts` file at all. If a subsequent section expects this file to exist, the build will break.

### 8. tsconfig.json has extra options not in the plan
`resolveJsonModule`, `isolatedModules`, and `noEmit` are added beyond what the plan specifies. These are generally fine and even beneficial for a Vite project.

### 9. Missing cleanup for state leaks between tests
Each test calls `render(<App />)` which triggers async state updates. The `waitFor` calls mitigate this partially.

### 10. The plan mentions TauRPC client mocking; the implementation mocks raw invoke
Direct consequence of issue #1 -- the test architecture is built around the wrong abstraction.
